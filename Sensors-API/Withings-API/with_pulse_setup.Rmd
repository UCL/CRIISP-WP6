---
title: "Python withingsAPI"
output: 
  github_document:
    toc: True
date: "`r format(Sys.time(), '%d %B, %Y')`"
---
```{r echo=F}
library("tidyr")

convert_to_ISOdate <- function(col_name) {
  if (grepl("\\.\\d{10}$", col_name)) {
    #extract the datafield name
    date_field<- sub("\\..*$", "", col_name)
    # Extract the Unix timestamp from the column name
    timestamp <- as.numeric(sub(".*\\.", "", col_name))
    
    # Convert the Unix timestamp to a human-readable date
    date <- as.POSIXct(timestamp, origin = "1970-01-01", tz = "")
    
    # Create a new column name with the human-readable date
    new_col_name <- paste0(date_field,".",format(date, format = "%Y%m%d-%H:%M:%S"))
    
    return(new_col_name)
  } else {
    return(col_name)
  }
}
convert_date <- function(date, output_type = c("numeric", "Date"),
                         tz="") {

  output_type <- match.arg(output_type, c("numeric", "Date"))

  # Always convert from character to date
  if( any(class(date) == "character" )) { date = as.Date(date) }

  if( output_type == "numeric" ) {

    # If to numeric, date --> POSIXct --> numeric

    if( any(class(date) == "Date" )) { date = as.POSIXct(date, tz=tz,
                                                         origin="1970-01-01") }
    if( any(class(date) == "POSIXct")) { date = as.numeric(date) }

  } else if( output_type == "Date" ) {

    # If to date, POSIXct --> Date

    if( any(class(date) == "POSIXct")) { date = as.Date(date) }

  }

  return(date)
}

```
## Withings pulse HR

## Prerequisites

Before being able to use this package, and the Withings Health Mate API, you will need to create a Withings account and a Withings developer app. Instructions are provided in the [developer's guide](http://developer.withings.com/oauth2/).

Note: when setting up an app, the Callback URL should be set to http://localhost:1410/. This is not supposed to be allowed, but it does seems to work, and I haven't been able to make it work using another address. 

## API plans
Withings Standard/Free Plan

Withings Standard/Free Plan includes:

* 5000 active users 
* 120 requests per minute for your API project 

## Security and compliance

### Withings EU Medical Cloud / Public Cloud (HIPAA/HDS)
Based in France, our EU Medical Cloud / Public Cloud is **GDPR compliant**, HDS, HIPAA and ISO 27001:2017 certified.
By design, our privacy policy ensures that user data is safely collected.

### Withings US Medical Cloud (HIPAA)

Withings complies with HIPAA rules and regulations so that our services can be more effectively integrated by entities that are covered by HIPAA. Our US Medical Cloud is a US based, ISO 27001:2017 certified and HIPAA compliant.



## API SPECS

DATA is fetched from Cloud not from the device directly (no websocket on dev)

Free for providers with under 5,000 users.


## API integration

### Create your Application
First, create the Withings account that will be used for your integration. Although using your personal Withings account is possible, we recommend that you create a new account for your organization. Creating an Application will provide you with a cliendId and client_secret that you will use to access our services.

#### Target endpoint

Please use the following endpoint for all requests you will perform on our APIs :

https://wbsapi.withings.net

## Use

### Callback URL

Note: when setting up an app, the Callback URL should be set to http://localhost:1410/. This is not supposed to be allowed, but it does seems to work. This is handy because allows for the callback to be (e.g.) on a laptop for testing.

```{r}
client_id <- "be15110fa9ce5d7f43eb15bd76fdf3ee84c6f25e1f7912db8bfa942d4556058a"
client_secret <- "781930cdc258cfddff8b5ee8eba1f0e12f3a48c5e181e2bb4fb3c907089287ab"
deviceid<- "decb53b35fc7a813ead55e84fd72bc7a3f1d4464"

userid<-32118337
access_token<-"d8b49dfe4e6d67705598dc7729a22f1be1077d01"


req <- httr::GET("https://wbsapi.withings.net/v2/user?action=getdevice", 
                 query = list(access_token = access_token))

httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

out$body$devices

```
## ACTIVITY

```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
#off-set <- #XX

  
startdate<-convert_date(startdate, "Date", tz)
enddate<-convert_date(enddate, "Date", tz)


req <- httr::GET("https://wbsapi.withings.net/v2/measure?action=getactivity", 
                 query = list(access_token = access_token,
                              startdateymd = startdate, 
                              enddateymd = startdate))#,
                              #offset = data_fields))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status


activityDF<-out$body$activities


```






## INTRA DAY ACTIVITY

```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
data_fields <-""

  
UnixStartDate <- startdate %>%  strptime("%Y-%m-%d") %>% as.numeric()
UnixEndDate <- enddate %>%  strptime("%Y-%m-%d") %>% as.numeric()


req <- httr::GET("https://wbsapi.withings.net/v2/measure?action=getintradayactivity", 
                 query = list(access_token = access_token,
                              startdate = UnixStartDate, 
                              enddate   = UnixEndDate,
                              data_fields = data_fields))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

if (out$status == 0) {
        out$body$series <- lapply(out$body$series, function(x) x[!sapply(x, 
            is.null)])
        out$body$series <- dplyr::bind_rows(out$body$series, 
            .id = "id")
        out$body$series$startdate <- as.POSIXct(as.numeric(out$body$series$id), 
            tz = "", origin = "1970-01-01")
    }

intraDayActivityDF<-out$body$series


```







## WORKOUTS
```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
#lastupdate  <-         #Timestamp for requesting data that were updated or 
                        #created after this date. Useful for data synchronization 
                        #between systems. Use this instead of startdateymd + enddateymd.

req <- httr::GET("https://wbsapi.withings.net/v2/measure?action=getworkouts", 
                 query = list(access_token = access_token,
                              startdateymd = startdate, 
                              enddateymd   = enddate,
                              data_fields = data_fields))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

if (out$status == 0 & length(out$body$series) > 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            origin = "1970-01-01")
    }

workoutsDF<-out$body$series


```








## HEART LIST
Returns a list of ECG records and Afib classification for a given period of time. To get the full ECG signal, use the Heart v2 - Get service.

If the ECG recordings have been taken with BPM Core, systole and diastole measurements will also be returned.
```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
off-set <- #XX


UnixStartDate <- startdate %>%  strptime("%Y-%m-%d") %>% as.numeric()
UnixEndDate <- enddate %>%  strptime("%Y-%m-%d") %>% as.numeric()


req <- httr::GET("https://wbsapi.withings.net/v2/heart?action=list", 
                 query = list(access_token = access_token,
                              startdate = UnixStartDate, 
                              enddate = UnixEndDate))#,
                              #offset = data_fields))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

out$body$offset

if (out$status == 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            tz = "", origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            tz = "", origin = "1970-01-01")
        out$body$series <- dplyr::arrange(out$body$series, startdate)
    }

HeartListDF<-out$body$series

new_col_names <- sapply(colnames(sleepDF), convert_to_ISOdate)
colnames(sleepDF) <- new_col_names


```

## HEART 
Provides the high frequency data of an ECG recording in micro-volt (Î¼V).


```{r eval=FALSE}

### BROKEN signalid??

req <- req <- httr::GET(url = "https://wbsapi.withings.net/v2/heart", 
        query = list(access_token = access_token, 
            action = "get", signalid = deviceid))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

out$body$offset

if (out$status == 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            tz = "", origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            tz = "", origin = "1970-01-01")
        out$body$series <- dplyr::arrange(out$body$series, startdate)
    }

HeartListDF<-out$body$series

new_col_names <- sapply(colnames(sleepDF), convert_to_ISOdate)
colnames(sleepDF) <- new_col_names


```


## SLEEP
```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
data_fields <-"hr,rr,snoring,sdnn_1,rmssd,mvt_score"
# > hr        : Heart Rate.
# > rr        : Respiration Rate.
# > snoring   : Total snoring time
# > sdnn_1    : Heart rate variability - Standard deviation of the NN over 1 minute
# > rmssd     : Heart rate variability - Root mean square of the successive 
#               differences over "a few seconds"
# > mvt_score : Track the intensity of movement in bed on a minute-by-minute basis. 
#               Only available for EU devices and devices under prescription.


UnixStartDate <- startdate %>%  strptime("%Y-%m-%d") %>% as.numeric()
UnixEndDate <- enddate %>%  strptime("%Y-%m-%d") %>% as.numeric()


req <- httr::GET("https://wbsapi.withings.net/v2/sleep?action=get", 
                 query = list(access_token = access_token,
                              startdate = UnixStartDate, 
                              enddate = UnixEndDate,
                              data_fields = data_fields))
httr::stop_for_status(req)
out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

if (out$status == 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            tz = "", origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            tz = "", origin = "1970-01-01")
        out$body$series <- dplyr::arrange(out$body$series, startdate)
    }

sleepDF<-out$body$series

new_col_names <- sapply(colnames(sleepDF), convert_to_ISOdate)
colnames(sleepDF) <- new_col_names


```

## SLEEP SUMMARY
```{r}

startdate   <-"2023-10-03" 
enddate     <-"2023-10-04"
data_fields <-""


req <- httr::GET("https://wbsapi.withings.net/v2/sleep?action=getsummary",
                 query = list(access_token = access_token,
                              startdateymd = startdate, 
                              enddateymd = startdate,
                              data_fields = data_fields))

out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

if (out$status == 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            tz = "", origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            tz = "", origin = "1970-01-01")
        out$body$series <- dplyr::arrange(out$body$series, startdate)
    }

sleepSumDF<-out$body$series

#new_col_names <- sapply(colnames(sleepDF), convert_to_ISOdate)
#colnames(sleepDF) <- new_col_names


```

## RAW data

curl --header "Authorization: Bearer YOUR_ACCESS_TOKEN" --data "action=activate&hash_deviceid=string&rawdata_type=int&enddate=enddate" 'https://wbsapi.withings.net/v2/rawdata '
```{r}

enddate     <-"2023-10-04"

UnixEndDate <- enddate %>%  strptime("%Y-%m-%d") %>% as.numeric()

req <- httr::GET("https://wbsapi.withings.net/v2/rawdata?action=activate",
                 query = list(access_token = access_token,
                              hash_deviceid = deviceid, 
                              rawdata_type = 2,
                              enddate = UnixEndDate))

out <- httr::content(req, as = "text", encoding = "utf-8")
out <- jsonlite::fromJSON(out)

out$status

if (out$status == 0) {
        out$body$series <- jsonlite::flatten(out$body$series)
        out$body$series$startdate <- as.POSIXct(out$body$series$startdate, 
            tz = "", origin = "1970-01-01")
        out$body$series$enddate <- as.POSIXct(out$body$series$enddate, 
            tz = "", origin = "1970-01-01")
        out$body$series <- dplyr::arrange(out$body$series, startdate)
    }

sleepSumDF<-out$body$series

#new_col_names <- sapply(colnames(sleepDF), convert_to_ISOdate)
#colnames(sleepDF) <- new_col_names


```